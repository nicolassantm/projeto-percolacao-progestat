[1mdiff --git a/prototipo_scipy_ndimage.ipynb b/prototipo_scipy_ndimage.ipynb[m
[1mindex db9cc22..7754e13 100644[m
[1m--- a/prototipo_scipy_ndimage.ipynb[m
[1m+++ b/prototipo_scipy_ndimage.ipynb[m
[36m@@ -2,144 +2,146 @@[m
  "cells": [[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 2,[m
[32m+[m[32m   "execution_count": 1,[m
    "id": "c7db32ec",[m
    "metadata": {},[m
    "outputs": [],[m
    "source": [[m
     "import numpy as np\n",[m
     "from scipy import ndimage\n",[m
[31m-    "import matplotlib.pyplot as plt"[m
[32m+[m[32m    "import matplotlib.pyplot as plt\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "np.random.seed(42) # semente escolhida"[m
    ][m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 8,[m
[31m-   "id": "afc4d9d6",[m
[32m+[m[32m   "execution_count": null,[m
[32m+[m[32m   "id": "41616c89",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "name": "stdout",[m
[31m-     "output_type": "stream",[m
[31m-     "text": [[m
[31m-      "O sistema percolou? False\n",[m
[31m-      "Qual o tamanho do maior cluster? 4\n",[m
[31m-      "Qual o n√∫mero total de clusters? 6\n"[m
[31m-     ][m
[31m-    }[m
[31m-   ],[m
[32m+[m[32m   "outputs": [],[m
    "source": [[m
[32m+[m[32m    "np.random.seed(42)\n",[m
     "def simulacao_percolacao(N, p):\n",[m
[31m-    "    percolou = False\n",[m
[31m-    "    maior_cluster = 0\n",[m
[31m-    "    num_clusters = 0\n",[m
[31m-    "\n",[m
[31m-    "    grade = np.random.rand(N, N) < p\n",[m
[31m-    "    grade = np.where(grade, 1, 0)\n",[m
[31m-    "\n",[m
[31m-    "    if not np.any(grade):\n",[m
[31m-    "        return False, 0, 0\n",[m
[31m-    "    # Se a matriz for inteiramente de zeros, j√° retorna que n√£o percola e n√£o teve clusters\n",[m
[31m-    "\n",[m
[31m-    "    estrutura = ndimage.generate_binary_structure(rank=2, connectivity=1)\n",[m
[31m-    "    # Define a estrutura de Vizinhos de von Neumann\n",[m
[31m-    "\n",[m
[31m-    "    grade_clusters, num_clusters = ndimage.label(grade, estrutura)\n",[m
[31m-    "    # Fun√ß√£o de etiquetar as matrizes em clusters\n",[m
[31m-    "\n",[m
[31m-    "    coluna_1 = grade_clusters[:, 0]\n",[m
[31m-    "    coluna_n = grade_clusters[:, -1]\n",[m
[31m-    "    linha_1 = grade_clusters[0]\n",[m
[31m-    "    linha_n = grade_clusters[-1]\n",[m
[31m-    "\n",[m
[31m-    "    intersecoes_vertical = np.intersect1d(linha_1, linha_n)\n",[m
[31m-    "    intersecoes_horizontal = np.intersect1d(coluna_1, coluna_n)\n",[m
[31m-    "    percolou_vertical = np.any(intersecoes_vertical > 0)\n",[m
[31m-    "    percolou_horizontal = np.any(intersecoes_horizontal > 0)\n",[m
[31m-    "    if percolou_vertical or percolou_horizontal:\n",[m
[31m-    "        percolou = True\n",[m
[31m-    "\n",[m
[31m-    "    grade_clusters_d1 = np.ravel(grade_clusters)\n",[m
[31m-    "    contagem = np.bincount(grade_clusters_d1)\n",[m
[31m-    "    # Conta ocupa√ß√£o de cada etiqueta de cluster\n",[m
[31m-    "    maior_cluster = max(contagem[1:])\n",[m
[31m-    "    # Maior cluster √© o elemento que ocupou mais s√≠tios (excluindo o zero)\n",[m
[31m-    "\n",[m
[31m-    "    return percolou, maior_cluster, num_clusters\n",[m
[31m-    "\n",[m
[31m-    "perc, maior, num = simulacao_percolacao(6, 0.5)\n",[m
[32m+[m[32m    "  ''' Recebe os par√¢metros N (o tamanho da matriz ser√° NxN) e p (probabilidade da entrada da matriz ser 1, e 0 caso contr√°rio),\n",[m
[32m+[m[32m    "retorna se a matriz percolou, o n√∫mero de clusters e o tamanho do maior cluster'''\n",[m
[32m+[m[32m    "  percolou = False\n",[m
[32m+[m[32m    "  maior_cluster = 0\n",[m
[32m+[m[32m    "  num_clusters = 0\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "  grade = np.random.rand(N, N) < p\n",[m
[32m+[m[32m    "  grade = np.where(grade, 1, 0)\n",[m
[32m+[m[32m    "  if not np.any(grade):\n",[m
[32m+[m[32m    "    return False, 0, 0\n",[m
[32m+[m[32m    "  # Se a matriz for inteiramente de zeros, j√° retorna que n√£o percola e n√£o teve clusters\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "  estrutura = ndimage.generate_binary_structure(rank=2, connectivity=1)\n",[m
[32m+[m[32m    "  # Define a estrutura de Vizinhos de von Neumann\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "  grade_clusters, num_clusters = ndimage.label(grade, estrutura)\n",[m
[32m+[m[32m    "  # Fun√ß√£o de etiquetar as matrizes em clusters\n",[m
[32m+[m[32m    "  coluna_1 = grade_clusters[:, 0]\n",[m
[32m+[m[32m    "  coluna_n = grade_clusters[:, -1]\n",[m
[32m+[m[32m    "  linha_1 = grade_clusters[0]\n",[m
[32m+[m[32m    "  linha_n = grade_clusters[-1]\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "  intersecoes_vertical = np.intersect1d(linha_1, linha_n)\n",[m
[32m+[m[32m    "  intersecoes_horizontal = np.intersect1d(coluna_1, coluna_n)\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "  percolou_vertical = np.any(intersecoes_vertical > 0)\n",[m
[32m+[m[32m    "  percolou_horizontal = np.any(intersecoes_horizontal > 0)\n",[m
[32m+[m[32m    "  if percolou_vertical or percolou_horizontal:\n",[m
[32m+[m[32m    "    percolou = True\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "  grade_clusters_d1 = np.ravel(grade_clusters)\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "  contagem = np.bincount(grade_clusters_d1)\n",[m
[32m+[m[32m    "  # Conta ocupa√ß√£o de cada etiqueta de cluster\n",[m
[32m+[m[32m    "  maior_cluster = max(contagem[1:])\n",[m
[32m+[m[32m    "  # Maior cluster √© o elemento que ocupou mais s√≠tios (excluindo o zero)\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "  return percolou, maior_cluster, num_clusters\n",[m
[32m+[m[32m    "\n",[m
[32m+[m[32m    "perc, maior, num = simulacao_percolacao(8, 0.5)\n",[m
     "print(f\"O sistema percolou? {perc}\")\n",[m
     "print(f\"Qual o tamanho do maior cluster? {maior}\")\n",[m
[31m-    "print(f\"Qual o n√∫mero total de clusters? {num}\")\n"[m
[32m+[m[32m    "print(f\"Qual o n√∫mero total de clusters? {num}\")"[m
    ][m
   },[m
   {[m
    "cell_type": "code",[m
[31m-   "execution_count": 10,[m
[31m-   "id": "e20f48d8",[m
[32m+[m[32m   "execution_count": 9,[m
[32m+[m[32m   "id": "696c227e",[m
    "metadata": {},[m
[31m-   "outputs": [[m
[31m-    {[m
[31m-     "data": {[m
[31m-      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA6cAAAL3CAYAAAB25TMzAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjUsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvWftoOwAAAAlwSFlzAAAPYQAAD2EBqD+naQAAhy9JREFUeJzt3Qm8VdP///F1q9tEk6JBpShzijKkZCiFUPQ1VSRDhhBlylT5RoSMEb6ELxVRZChDaFAiEpHMiibNc93u3f/He33/+/z2Pfecc8+559y7zu28no/HaTjj2muvvfb6rLX22lme53kGAAAAAACHyrj8cQAAAAAAhOAUAAAAAOAcwSkAAAAAwDmCUwAAAACAcwSnAAAAAADnCE4BAAAAAM4RnAIAAAAAnCM4BQAAAAA4R3AKAAAAAHAubYLTrKws+xg8eLApDV544YVQmv/4448Cr59wwgn2Nf2d7mlNhZEjR5qGDRua3Xff3XTq1Ml88skn9vlx48bZ333sscdMaXHxxRfbNDdq1MhkGh1/flkBAOza3njjDdO0aVNTuXJl06ZNGzNhwgT7/Oeff27PA/3793edxIw+J6P0KS3tqDvuuMPUqVPHVKtWzXTr1s3MmzfPPn/ffffZtE+aNMlZ2sol+oFPP/3UnHjiiQWeL1u2rKlatardyAYNGpiWLVuatm3bmjPOOMOUL18+VelFGlKBvvbaa43nefb/H3zwgX0ccMAB5u+//7aFvF27dq6TCQAA/r9ly5aZnj17mm3bttn/z5o1yz4aN25s1q9fb59Lhw52AKn15ptvmnvuuSf0f3VKTZw40RxyyCHmp59+MpUqVTJHHXWUKfUjp7m5uWbt2rV2ZG7GjBnmkUceMf/6179M/fr1zdChQ83OnTuNC+k0grmrmj59ug1Mb7vtNjN79mwzZMgQ07x5c/Pnn3+a6tWr21HVFi1auE4mdgH0oANAanzxxRc2MFW9qn8/+OCD5phjjjErVqww5cqVsyMrZ555putkAkixadOm2b8ff/xxG7PddNNNdkBJgakGGF9++WU7qlpqRk6DrrrqKnP11VeH/r9p0yYboH777bdm6tSp5qOPPjL//POPufPOO83bb79t3nnnHbPnnntG/C5/1K20UGWuR2lQ3Gnt16+fffh0crvrrruK7fcAAEByunTpkq/tdeSRR5oBAwY4TROA4vfwww/bh08zXYcPH27SRVLB6V577WUOPfTQAs+feuqp5pZbbjE//PCDnTKiaZ/qlTvrrLPMxx9/zDRfAAAAAEDJLYh08MEHm88++8wcfvjh9v/6t6Z4AgAAAABQoqv16qLa//73v6FVq3RNQ05OTsKr9a5bt85evNu6dWtTo0YNk52dbacIKwDWiOxTTz1lr5MIvzbNn1etv/3f8B/h162Fp0GjvOecc46df63fC74/0RVwFy1aZPr06WMXGqhYsaKpW7euOffcc+2KeLEWn/J/Q/+OJVb+xZvWvLw8M3bsWLtql1be1b7TY//99zc9evQwr7/+esR9p2nc//73v03Hjh3tNcYVKlSwq/ZqBUDthzlz5ph47Nixwzz55JN2wS3tW42wa877aaedZue/K32psHDhQpsu7VftC/3